var documenterSearchIndex = {"docs":
[{"location":"intro/#Introduzione","page":"Introduzione","title":"Introduzione","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"<img src=\"images/sparse.png\" alt=\"matricesparsa\" width=\"500\"/>","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Linear Algebric Representation (d'ora in avanti LAR) LAR è uno schema di rappresentazione generale per la modellazione geometrica e topologica (vedi \\\"Rappresentazione algebrica lineare per strutture topologiche\\\"). Il dominio dello schema è fornito da complessi cellulari mentre il suo codominio è un insieme di matrici sparse. Altro non è che un package scritto in linguaggio Julia per il calcolo geometrico di figure piane e solide. Essa fa uso della API (Application Programming Interface) ViewerGL, sviluppato dalla nostra università da una fork di Plasm.jl.","category":"page"},{"location":"intro/#Matrici-Sparse","page":"Introduzione","title":"Matrici Sparse","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Nell'analisi numerica e nel calcolo scientifico, una matrice sparsa o un array sparso è una matrice in cui la maggior parte degli elementi è zero. Non esiste una definizione rigida per quanto riguarda la proporzione di elementi con valore zero affinché una matrice si qualifichi come sparsa, ma un criterio comune è che il numero di elementi diversi da zero è all'incirca uguale al numero di righe o colonne. Al contrario, se la maggior parte degli elementi è diversa da zero, la matrice è considerata densa. Il numero di elementi di valore zero diviso per il numero totale di elementi (ad esempio, m × n per una matrice m × n) è talvolta indicato come la scarsità della matrice.","category":"page"},{"location":"intro/#Complessi-di-Celle","page":"Introduzione","title":"Complessi di Celle","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Una cella n-dimensionale chiusa è uno spazio topologico che è omeomorfo ad una palla chiusa n-dimensionale. Per esempio, un simplesso è una cella chiusa, e più in generale, un politopo convesso è una cella chiusa. Una cella n-dimensionale aperta è uno spazio topologico omeomorfo alla palla aperta n-dimensionale. Una cella 0-dimensionale aperta (e chiusa) è un punto. Informalmente, un complesso di celle è uno spazio topologico ottenuto incollando fra loro un certo numero di celle chiuse. Formalmente, un complesso di celle è uno spazio di Hausdorff chi dotato di una partizione in celle aperte (di dimensioni variabili) che soddisfa due proprietà:","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Per ogni cella n-dimensionale aperta C nella partizione di X, esiste  una mappa continua f della palla n-dimensionale chiusa su X tale che\nla restrizione di f all'interno della palla chiusa è un   omeomorfismo sulla cella C, e\nl'immagine del contorno della palla chiusa è contenuta   nell'unione di un numero finito di celle aventi tutte dimensione   inferiore ad n.\nUn sottoinsieme di X è chiuso se e soltanto se incontra la chiusura  di ciascuna cella in un insieme chiuso.","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Il termine CW-complesso, mutuato dall'inglese, è a volte usato come sinonimo di complesso di celle. Le lettere C e W indicano i termini inglesi closure-finite e weak-topology e si riferiscono alle due proprietà elencate (la seconda proprietà infatti indica che la topologia su X è in un certo senso una topologia debole).","category":"page"},{"location":"intro/#Illustrazione-delle-principali-primitive","page":"Introduzione","title":"Illustrazione delle principali primitive","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"In questa sezione vengono descritte le principali primitive contenute nel package mapper.jl oggetto del lavoro di ottimizzazione previsto dal progetto.","category":"page"},{"location":"intro/#Lar.approxVal","page":"Introduzione","title":"Lar.approxVal","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Lo scopo di questa funzione è molto semplice: fornendo in input un valore e un numero di cifre significative approssima il valore al numero di cifre richieste. Qualora il risultato fosse -0.0 il segno viene cambiato.","category":"page"},{"location":"intro/#Lar.simplifyCells","page":"Introduzione","title":"Lar.simplifyCells","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"A causa di errori numerici sulle coordinate mappate potrebbero verificarsi duplicazioni di vertici. Questa funzione ausiliaria trova ed elimina vertici duplicati e celle errate. I paramentri di input sono CV (vettore di vettori) e V (matrice).   Viene creato un dizionario vertDict con chiave una colonne della matrice e valore un contatore incrementale. Per ogni vettore incell di CV la funzione crea un vettore vuoto outcell e per ogni elemento di v di incell preleva la colonna corrispondente di V. Applica la funzione approxVal ad ogni elemento della colonna.   Se la colonna non è presente nel dizionario, incrementa l'indice e la inserisce nel dizionario con chiave il nuovo valore dell'indice. Inoltre aggiunge l'indice ad outcell e la colonna alla matrice W di output.   Se invece la colonna appartiene già al dizionario, aggiunge ad outcell l'indice corrispondente presente nel dizionario. Infine l'eliminazione dei duplicati da outcell avviene mediante la creazione di un Set che per definizione non può contenere valori uguali.","category":"page"},{"location":"intro/#Lar.circle","page":"Introduzione","title":"Lar.circle","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Calcola l'approssimazione di una circonferenza centrata nell'origine prendendo come input raggio, angolo e numero di segmenti utilizzati per l'approssimazione. Per la creazione di vertici e spigoli sfrutta la funzione cuboidGrid descritta nel modulo largrid.jl.   La funzione moltiplica ogni vertice per il rapporto fra l'angolo e i segmenti inseriti in input.  Mappa ogni vertice come segue:","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"e inserisce le coppie così generate in un vettore. Dopodiché affianca ogni vettore ottenendo una matrice con un numero di elementi doppi rispetto alla precedente.   Infine applica simplifyCells al risultato.","category":"page"},{"location":"intro/#Lar.toroidal","page":"Introduzione","title":"Lar.toroidal","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Calcola una approssimazione del toro, ovvero una superficie di rotazione ottenuta dalla rivoluzione di una circonferenza in uno spazio tridimensionale intorno a un asse ad essa complanare. Gli input richiesti sono raggio e angolo della circonferenza e della superficie di rotazione, oltre al numero di segmenti richiesti per l'approssimazione.   La descrizione della funzione è simile alla precedente. Per la creazione di vertici e spigoli sfrutta la funzione simplexGrid descritta nel modulo simplexn.jl.   La matrice V ottenuta possiede due righe ciascuna delle quali rappresenta i vertici di ciascuna delle due figure. Viene effettuato un prodotto fra V e una matrice 2 x 2 con il rapporto fra l'angolo e il numero segmenti inseriti in input rispettivamente per la prima e la seconda figura sulla diagonale principale e degli 0 sulla diagonale secondaria.   Vengono estratte una per volta tutte le colonne di V mappandole nel seguente modo:","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"(Image: )","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Infine applica simplifyCells al risultato.","category":"page"},{"location":"intro/#Lar.cuboid","page":"Introduzione","title":"Lar.cuboid","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Restituisce un cubo d-dimensionale dove d è la dimensione comune degli array di input minpoint e maxpoint.   Per la creazione di vertici e spigoli sfrutta la funzione cuboidGrid descritta nel modulo largrid.jl. Dopodiché tramite le funzioni esterne s e t crea delle matrici, le moltiplica fra loro e applica la funzione esterna apply al risultato.","category":"page"},{"location":"lar/#LAR","page":"Lar Introduction","title":"LAR","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"LAR is a general representation scheme for geometric and topological modeling (see \"Linear algebraic representation for topological structures\"). The domain of the scheme is provided by cellular complexes while its codomain is a set of sparse matrices. The main advantages of the scheme are:","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"It is extremely effective to easily represent general non-manifold solids.  For example, the memory representation of a d=3 cellular complex using LAR consists in only two binary sparse matrices for the topology and a bi-dimensional array for the geometry.\nComputation and analysis of cellular complexes is done only through easy linear algebra operations.  The most common operation is the sparse matrix-vector multiplication.","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"Here a list of fundamental concepts and features of LAR: ","category":"page"},{"location":"lar/#LAR-model","page":"Lar Introduction","title":"LAR model","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"A LAR model is a pair geometry, topology.  The geometry is specified by the position vectors of vertices in a Euclidean  space mathbbE^d of points with d coordinates. The topology is specified by one  or more bases of singleton k-chains (i.e.~k-cells) for 0 leq kleq d.  The vertex sharing between cells implicitly provides the attachment maps between  cells of various dimensions. Vertex positions are represented, by columns, by a  2-array of d real coordinates.","category":"page"},{"location":"lar/#Chains-as-arrays","page":"Lar Introduction","title":"Chains as arrays","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"Chain-based modeling and computing (refer to \"Chain-Based Representations for Solid and Physical Modeling\")  is based on representation of p-cell subsets as chains, elements of linear spaces C_p (0leq pleq d) generated by the space decomposition induced by a cellular complex, also said CW-complex. Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing. Therefore, basic algebraic operations on chains as  vectors (sum and product times a scalar) are implemented over arrays.","category":"page"},{"location":"lar/#Characteristic-matrices","page":"Lar Introduction","title":"Characteristic matrices","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"The LAR representation scheme, i.e. our  mapping between mathematical models of solids and their computer representations, uses linear chain spaces C_p as models, and sparse characteristic matrices M_p of p-cells as symbolic representations, where the p-cell sigma^kinLambda_p is represented as the k-th binary row of the sparse characteristic matrix M_p C_0to C_p.","category":"page"},{"location":"lar/#Boundary-and-coboundary-matrices","page":"Lar Introduction","title":"Boundary and coboundary matrices","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"The boundary matrix partial_p is the matrix of the boundary operator  partial_p C_pto C_p-1 (1leq pleq d) that for each chain c_pin C_p  returns the boundary (p-1)-cycle of its (d-1)-faces. A boundary operator is linear:  partial_p c + d = partial_p c + partial_p d, for each cdin C_p. A cycle is a  chain without boundary. Hence, the boundary of a boundary is the zero map:  partial_p-1 circ partial_p = 0 (2leq pleq d).","category":"page"},{"location":"lar/#Incidence-matrices","page":"Lar Introduction","title":"Incidence matrices","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices, possibly transposed. Since both characteristic and operator matrices are very sparse, their products are computed  with specialized algorithms for sparse matrices, whose complexity is roughly linear in the size  of the output sparse matrix, i.e., in the number of its stored non-zero elements. Incidence queries and other types of geometric or topological computations are not  performed element-wise, that necessarily require iterative or recursive programming patterns,  but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures.","category":"page"},{"location":"lar/#Validity-test-of-a-representation","page":"Lar Introduction","title":"Validity test of a representation","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"Data validity is easy to test by checking for satisfaction of basic equations  partialpartial=emptyset of a chain complex.","category":"page"},{"location":"lar/#Space-arrangments","page":"Lar Introduction","title":"Space arrangments","text":"","category":"section"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"Given a finite collection mathcalS of cellular complexes in mathbbE^d, d in 23, the \\emph{arrangement} mathcalA(mathcalS) is the decomposition of mathbbE^d into connected cells of dimensions 0 1 ldots d  induced by mathcalS. In Lar.jl, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D.  The goal here is to provide a complete description of the plane or space decomposition  induced by the input, into cells of dimensions 0, 1, 2 or 3. This computation is based  on the algorithms introduced in \\cite{DBLP:journals/corr/PaoluzziSD17} which describe how  to compute the d-space arrangement generated by a collection of (d-1)-complexes.  A general description of both the motivations and the features of the space arrangement  and Lar.jl in general are given in~\\cite{DBLP:journals/corr/abs-1710-07819}.","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"With abuse of language, we consider a finite cellular complex X as generated by a discrete  partition of an Euclidean space. In computing a cellular complex as the space arrangement of  a collection of geometric objects mathcalS, i.e. when  X = mathcalA(mathcalS),  we actually compute the whole chain complex C_bullet generated by X, i.e.:","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"(Image: chains)","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"where C_p (0geq pgeq 3) is a linear space of \\emph{p-chains} (subsets of p-cells  with algebraic structure). The linear operators partial_p and delta_p are the boundary  and coboundary operators as described before, respectively with","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"partial_p-1circpartial_p  = emptyset = delta_pcircdelta_p-1","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"and where ","category":"page"},{"location":"lar/","page":"Lar Introduction","title":"Lar Introduction","text":"delta_p-1 = partial_p^top quad 1leq pleq 3","category":"page"},{"location":"stateart/#Stato-dell'arte","page":"Stato dell'arte","title":"Stato dell'arte","text":"","category":"section"},{"location":"stateart/","page":"Stato dell'arte","title":"Stato dell'arte","text":"(Image: Visualizzazione grafica della funzione \\\"pizza\\\")","category":"page"},{"location":"stateart/","page":"Stato dell'arte","title":"Stato dell'arte","text":"Nel momento in cui abbiamo preso in mano questo progetto, esso si presentava con pochi difetti in realtà. Al di là di qualche problema di configurazione iniziale dovuta a delle dipendenze Julia non soddisfatte, infatti, l'unico intervento necessario era quello di ottimizzare i tempi di esecuzione. Non erano quindi presenti errori veri e propri nel codice, ma il nostro obbiettivo era quello di migliorare le prestazioni del programma.","category":"page"},{"location":"stateart/#Mapper.jl","page":"Stato dell'arte","title":"Mapper.jl","text":"","category":"section"},{"location":"stateart/","page":"Stato dell'arte","title":"Stato dell'arte","text":"L'obbiettivo primario del file mapper.jl contiene l'implementazione di diverse primitive parametriche, incluse curve, superfici e solidi incorporati in 2D o 3D. L'approccio costruttivo è comune a tutti i metodi. Consiste nel generare una scomposizione semplice o cuboidale di un semplice dominio geometrico in u,v o u,v,w spazio parametrico. Quindi un cambio di coordinate, ad es. da coordinate cartesiane a coordinate polari o cilindriche, si applica ai vertici della cellula complesso che decompone il dominio.\nLinearAlgebricRepresentation, come il suo linguaggio geometrico antenato PLASM e la sua libreria padre pyplasm mira ad essere multidimensionale. Quindi alcune funzioni generano modelli geometrici di dimensioni variabili. Esempi importanti sono cuboidGrid e simplexGrid, il cui parametro unico è la forma della mesh generata, ovvero il numero di celle d-dimensionali in ciascuna dimensione, con d = lunghezza(forma). I vertici della mesh rimangono sulla griglia intera di dimensioni e dimensioni adeguate.","category":"page"},{"location":"stateart/","page":"Stato dell'arte","title":"Stato dell'arte","text":"(Image: Una Visualizzazione grafica di due cubi tramite ViewerGL)","category":"page"},{"location":"grafodipendenze/#Grafo-delle-Dipendenze","page":"Dependecy Graph","title":"Grafo delle Dipendenze","text":"","category":"section"},{"location":"grafodipendenze/","page":"Dependecy Graph","title":"Dependecy Graph","text":"(Image: image)","category":"page"},{"location":"conclusioni/#Conclusioni-e-Sviluppi-Futuri","page":"Conclusione","title":"Conclusioni e Sviluppi Futuri","text":"","category":"section"},{"location":"conclusioni/","page":"Conclusione","title":"Conclusione","text":"Compito di chi verrà dopo di noi sarà quello di sfruttare questa libreria per un calcolo geometrico veloce ed ottimizzato, con la speranza che il nostro lavoro venga messo a servizio di grandi realtà.","category":"page"},{"location":"applicazione/#Applicazione-Pratica","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"","category":"section"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"In questo capitolo andiamo a presentare quella che è stata la nostra esperienza: i nostri esperimenti, tentativi falliti e riusciti, quesiti aperti e altro.","category":"page"},{"location":"applicazione/#Tecniche-Minimali","page":"Applicazione Pratica","title":"Tecniche Minimali","text":"","category":"section"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"Inizialmente le tecniche che abbiamo adoperato sono state tratte dal libro \\\"Julia High Performance: Optimizations, distributed computing, multithreading, and GPU programming with Julia 1.0 and beyond\\\" [@julia]. Purtroppo questo tentativo è stato fallimentare: non abbiamo registrato miglioramenti significativi, o non ne abbiamo registrati affatto.","category":"page"},{"location":"applicazione/#CuboidGrid-e-SimplexGrid","page":"Applicazione Pratica","title":"CuboidGrid e SimplexGrid","text":"","category":"section"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"In questa seconda fase abbiamo cercato di ridurre i tempi di esecuzione tranne la realizzazione di domini di funzioni esterni al codice. La nostra idea era quella di utilizzare dei file di configurazione per poter ridurre i tempi di calcolo a discapito dei tempi di caricamento. Questo è stato possibile tramite il package Julia Artifacts.jl, ma si è rivelata una soluzione solo parzialmente efficace.","category":"page"},{"location":"applicazione/#Realizzazione-su-GPU","page":"Applicazione Pratica","title":"Realizzazione su GPU","text":"","category":"section"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"L'obbiettivo di questa ultima fase è stato quello di riuscire a trasportare il calcolo di queste funzioni dalla CPU alla GPU Nvidia fornita dal nostro ateneo. Infatti, RomaTre ha messo a disposizione un superserver con circa 8 schede grafiche per agevolare i nostri test. Di seguito abbiamo inserito una foto dell'esecuzione del comando nvidia-smi:","category":"page"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"(Image: Esecuzione del comando 'nvidia-smi' sulla macchina dgx)","category":"page"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"2 Questa trasformazione in buona sostanza consiste nel passaggio dalla struttura dati QArray al posto della struttura Array. I benchmark eseguiti e i test effettuati sulla versione finale del progetto riportano risultati incoraggianti, i quali sono riportati sia sul notebook che di seguito, dimostrano che i tempi di esecuzione, per la memoria occupata, sono molto buoni ed incoraggianti:","category":"page"},{"location":"applicazione/","page":"Applicazione Pratica","title":"Applicazione Pratica","text":"(Image: image)","category":"page"},{"location":"background/#Background-Tecnologico","page":"BackGround Tecnologico","title":"Background Tecnologico","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"In questo progetto abbiamo fatto uso di diverse tecnologie, a partire dal linguaggio Julia, utilizzato per implementare tutto quanto, passando poi per gli elementi principali della programmazione, come i task, il multithreading e infine implementando tutto in modo tale da sfruttare la potenza di calcolo di una GPU NVidia.","category":"page"},{"location":"background/#Julia","page":"BackGround Tecnologico","title":"Julia","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Julia è un linguaggio di programmazione dinamico di alto livello, ad alte prestazioni. Sebbene sia un linguaggio generico e possa essere utilizzato per scrivere qualsiasi applicazione, molte delle sue caratteristiche sono adatte per l'analisi numerica e la scienza computazionale. Aspetti distintivi del design di Julia includono un sistema di tipi con polimorfismo parametrico in un linguaggio di programmazione dinamico; con invio multiplo come paradigma di programmazione principale. Julia supporta l'elaborazione simultanea, parallela (componibile) e distribuita (con o senza l'utilizzo di MPI o il corrispondente integrato ai thread \\\"stile OpenMP\\\") e la chiamata diretta di C e librerie Fortran senza codice colla. Julia utilizza un compilatore just-in-time (JIT) denominato \\\"just-ahead-of-time\\\" (JAOT) nella community di Julia, poiché Julia compila tutto il codice (per impostazione predefinita) in codice macchina prima di eseguirlo. Julia è raccolta di rifiuti, utilizza la valutazione desiderosa e include librerie efficienti per calcoli a virgola mobile, algebra lineare, generazione di numeri casuali e corrispondenza di espressioni regolari. Sono disponibili molte librerie, incluse alcune (ad es. per trasformazioni di Fourier veloci) che erano state precedentemente fornite in bundle con Julia e ora sono separate. Diversi strumenti di sviluppo supportano la codifica in Julia, come ambienti di sviluppo integrati (ad es. Visual Studio Code di Microsoft, con estensioni disponibili che aggiungono il supporto di Julia agli IDE, ad es. fornendo supporto per debug e linting); con strumenti integrati, ad es. un profiler (e il supporto per i grafici di fiamma disponibili per quello integrato), un debugger e il pacchetto Rebugger.jl \\\"supporta il debug a esecuzione ripetuta\\\" e altro ancora.","category":"page"},{"location":"background/#Julia-Artifacts","page":"BackGround Tecnologico","title":"Julia Artifacts","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Gli artefatti[@artifacts] in Julia esistono sotto forma di un modulo all'interno del modulo Pkg chiamato Pkg.Artifacts. Si accede alla funzionalità nel REPL tramite:","category":"page"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":" julia> using Pkg.Artifacts","category":"page"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Se inserire immagini, file binari, set di dati e dati simili nei repository git fosse indolore e senza problemi, potremmo non aver bisogno di Artifacts.\nIl problema è che per i file binari i requisiti di spazio possono diventare eccessivi abbastanza rapidamente. Compilare una versione per ogni piattaforma, 32-bit, 64-bit e una moltitudine di altre varianti e mantenerla nella libreria del codice sorgente è una pratica troppo onerosa: ci vorrebbe troppo spazio.\nCon Artifacts, più pacchetti potrebbero in linea di principio utilizzare gli stessi dati e non è necessario scaricarli due volte. Facciamo conto che il pacchetto A e il pacchetto B, entrambi dipendono dalla libreria Qt. La soluzione fittizia a questo è che entrambe le librerie memorizzino una copia di Qt.\nBisognerebbe quindi scaricare un'enorme libreria due volte sprecando il doppio dello spazio sul disco rigido. Non è una buona soluzione. Ora qualcun altro potrebbe pensare di essere intelligente e archiviare Qt in una directory condivisa per entrambi i pacchetti da usare. Vari sistemi operativi lo hanno fatto all'inizio e hanno creato la cosa divertente che chiamiamo \\\"inferno DLL\\\". Ciò accade quando la versione Qt richiesta non è proprio la stessa. La versione scaricabile Qt potrebbe funzionare per A, ma non per B.\nGit ha reso popolare una soluzione a questo enigma chiamato dati indirizzabili al contenuto. Ciò significa che non localizzano i dati fornendo percorsi come A/libs/Qt, ma usiamo invece degli hash.\nIn questo caso, ogni byte dei binari della libreria Qt viene inserito in un algoritmo di hashing e crea un numero univoco, l'hash. In teoria, ovviamente, non è possibile garantire che due set di dati producano hash diversi. La possibilità che diversi set di dati producano lo stesso hash è simile a quella di due persone in posizioni casuali sulla terra che raccolgono lo stesso granello di sabbia. Potrebbe succedere, ma è improbabile.\nIl sistema di pacchetti Julia può quindi verificare se una libreria è stata già installata controllando se esiste già una directory con un hash ed evitare di scaricare la stessa libreria una seconda volta.\nUn altro problema risolto con Artifacts è che si evita di gonfiare il proprio repository con file binari. Supponiamo che tu abbia un pacchetto Museo con il codice per mostrare i quadri. Invece di inserire una directory quadri nel repository del pacchetto con le immagini di ogni opera d'arte, crei un file Artifacts.toml. In esso descrivi dove si trovano le varie immagini in una maniera simile a questa:","category":"page"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"    # Museo/Artifacts.toml \n    [pictures]\n    git-tree-sha1 = \"c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2\"\n    lazy = true\n\n    [[pictures.download]]\n    sha256 = \"2aea399ab3c6b6e3a4285ec6ae31b858803442bf1b3e3e4889a2e3e8287d56c6\"\n    url = \"https://github.com/johndoe/Museo.jl/releases/download/pictures.tar.gz\"","category":"page"},{"location":"background/#Thread","page":"BackGround Tecnologico","title":"Thread","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Un thread è un singolo flusso sequenziale di controllo all'interno di un programma. [@threads]\nLa vera eccitazione che circonda i thread non riguarda un singolo thread sequenziale. Piuttosto, si tratta dell'uso di più thread in esecuzione contemporaneamente ed eseguire attività diverse in un unico programma. Questo uso è illustrato nella figura successiva.\nUn browser Web è un esempio di applicazione multithread. All'interno di un browser tipico, puoi scorrere una pagina mentre sta scaricando un'applet o un'immagine, riprodurre animazioni e suoni contemporaneamente, stampare una pagina in background mentre scarichi una nuova pagina o guardare tre algoritmi di ordinamento che corrono verso il traguardo.\nAlcuni testi chiamano un thread un processo leggero. Un thread è simile a un processo reale in quanto entrambi hanno un unico flusso sequenziale di controllo. Tuttavia, un thread è considerato leggero perché viene eseguito nel contesto di un programma completo e sfrutta le risorse allocate per quel programma e l'ambiente del programma.  ","category":"page"},{"location":"background/#Tasks","page":"BackGround Tecnologico","title":"Tasks","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Una coroutine o task è simile a un thread: è una linea di esecuzione, con il proprio stack, le proprie variabili locali e il proprio puntatore alle istruzioni; il tutto però è condiviso con altre coroutine. La principale differenza tra thread e coroutine è che, concettualmente (o letteralmente, in una macchina multiprocessore), un programma con thread esegue diversi thread in parallelo. Le coroutine, d'altra parte, sono collaborative: in un dato momento, un programma con coroutine esegue solo una delle sue coroutine e questa coroutine in esecuzione sospende la sua esecuzione solo quando richiede esplicitamente di essere sospesa. [@tasks]\nL'istruzione 'yield' in Julia ha lo scopo di creare coroutine. Quando si incontra l'istruzione 'yield', lo stato corrente della funzione viene salvato e il controllo viene restituito alla funzione chiamante. La funzione chiamante può quindi ritrasferire l'esecuzione alla funzione cedente e il suo stato verrà ripristinato al punto in cui è stato riscontrato lo 'yield' e l'esecuzione continuerà.","category":"page"},{"location":"background/#Architettura-Tesla","page":"BackGround Tecnologico","title":"Architettura Tesla","text":"","category":"section"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"Tesla è il nome in codice di una microarchitettura GPU sviluppata da Nvidia e rilasciata nel 2006, come successore della microarchitettura Curie. Prende il nome dal pioniere dell'ingegnere elettrico Nikola Tesla. Come prima microarchitettura di Nvidia a implementare gli shader unificati, è stata utilizzata con GeForce serie 8, GeForce serie 9, serie GeForce 100, serie GeForce 200 e serie GeForce 300 di GPU prodotte collettivamente in 90 nm, 80 nm, 65 nm, 55 nm, e 40 nm. Era anche nella GeForce 405 e nei moduli di elaborazione Quadro FX, Quadro x000, Quadro NVS e Nvidia Tesla. Tesla ha sostituito le vecchie microarchitetture a pipeline fissa, rappresentate al momento dell'introduzione dalla serie GeForce 7. Ha gareggiato direttamente con la prima microarchitettura shader unificata di AMD denominata TeraScale, uno sviluppo del lavoro di ATI su Xbox 360 che utilizzava un design simile. Tesla è stato seguito da Fermi.","category":"page"},{"location":"background/","page":"BackGround Tecnologico","title":"BackGround Tecnologico","text":"(Image: Architettura Tesla di GPU Nvidia)","category":"page"},{"location":"#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"This page has references to all exported types and functions.","category":"page"},{"location":"#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"DefaultDict","category":"page"},{"location":"#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"simplifyCells\ncircle\ncirlceOpt\nhelix\ndisk\nhelicoid\nring\ncylinder\nsphere\ntoroidal\ntoroidalOpt\ncrown\ncuboid\ncuboidOpt\nball\nrod\nhollowCyl\nhollowBall\ntorus\npizza","category":"page"},{"location":"mapper/#Solid-primitives-by-domain-mapping","page":"General Informations","title":"Solid primitives by domain mapping","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"The mapper.jl file contains the implementation of several parametric primitives, including curves, surfaces and solids embedded in either 2D or 3D.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"The constructive approach is common to all methods. It consists in generating a simplicial or cuboidal decomposition of a simple geometrical domain in u,v or u,v,w parametric space. Then a change of coordinates, e.g. from Cartesian to polar or cylindrical coordinates, is applied to the vertices of the cellular complex decomposing the domain.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"(Image: )","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Figure 1: Cellular 3-complexes, slightly exploded: (a) cuboidal mesh; (b) simplicial mesh.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"So, the mapped domain produces a curved manifold in 2D or 3D space. To obtain a closed curved surface, i.e. a manifold-without-boundary, as in the case of a 2-sphere in 3D, or of the toroidal surface in 3D, a suitable identification of coincident mapped points is performed. ","category":"page"},{"location":"mapper/#Basics-of-LAR-models","page":"General Informations","title":"Basics of LAR models","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"A very simple LAR model is a 2D square with a vertex on the origin: ","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> square=([[0.; 0] [0; 1] [1; 0] [1; 1]], [[1,2,3,4]], [[1,2], [1,3], [2,4], [3,4]])\r\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\r\n[1, 3], [2, 4], [3, 4]])\r\n","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Conventional names for the arrays of vertices, faces and edges:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> V,FV,EV = square\r\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\r\n[1, 3], [2, 4], [3, 4]])","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"V may be either of type Array{Float64,2} or Array{Int64,2}","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> Lar = LinearAlgebraicRepresentation\r\n\r\njulia> V::Lar.Points\r\n2×4 Array{Float64,2}:\r\n 0.0  0.0  1.0  1.0\r\n 0.0  1.0  0.0  1.0","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"The arrays containing the p-dimensional (2leq pleq d) cells of a d-complex must be of type Array{Array{Int64,1},1}, where each element contains the unordered array of indices of vertices on the boundary of the cell:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> EV::Lar.Cells\r\n4-element Array{Array{Int64,1},1}:\r\n [1, 2]\r\n [1, 3]\r\n [2, 4]\r\n [3, 4]","category":"page"},{"location":"mapper/#*Cuboidal*-and-*simplicial*-grids","page":"General Informations","title":"Cuboidal and simplicial grids","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"LinearAlgebraicRepresentation, as its ancestor geometric language PLaSM and its father library pyplasm aims to be multidimensional. Hence some functions generate geometric models of varying dimensions. Important examples are cuboidGrid and simplexGrid, whose unique parameter is the shape of the generated mesh, i.e. the number of d-dimensional cells in each dimension, with d = length(shape). The vertices of the mesh stay on the integer grid of suitable dimension and size.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> shape = [1,1,1]\r\n\r\njulia> Lar.cuboidGrid(shape)\r\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \r\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Hence we have, for single-cell 1-, 2-, 3-, and 4-dimensional LAR models:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> Lar.cuboidGrid([1])\r\n([0.0 1.0], Array{Int64,1}[[1, 2]])\r\n\r\njulia> Lar.cuboidGrid([1,1])\r\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]])\r\n\r\njulia> Lar.cuboidGrid([1,1,1])\r\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0], \r\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])\r\n\r\njulia> Lar.cuboidGrid([1,1,1,1])\r\n([0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 1.0 … 0.0 1.0],\r\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]])","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Two examples follows for a  20times 20  mesh in 2D, and a 20times 20times 20   mesh in 3D. Of course, their highest dimensional cells (quads and hexs) have 4 and 8 vertices, respectively.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> Lar.cuboidGrid([20,20])\r\n([0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2, 22, 23], [2, 3, 23,\r\n24], [3, 4, 24, 25], [4, 5, 25, 26], [5, 6, 26, 27], [6, 7, 27, 28], [7, 8, 28, 29], [8,\r\n9, 29, 30], [9, 10, 30, 31]  …  [415, 416, 436, 437], [416, 417, 437, 438], [417, 418,\r\n438, 439], [418, 419, 439, 440], [419, 420, 440, 441]])\r\n\r\njulia> Lar.cuboidGrid([20,20,20])\r\n([0.0 0.0 … 20.0 20.0; 0.0 0.0 … 20.0 20.0; 0.0 1.0 … 19.0 20.0], Array{Int64,1}[[1, 2,\r\n22, 23, 442, 443, 463, 464], [2, 3, 23, 24, 443, 444, 464, 465], [3, 4, 24, 25, 444, 445,\r\n465, 466]  …   [8797, 8798, 8818, 8819, 9238, 9239, 9259, 9260], [8798, 8799, 8819, 8820,\r\n9239, 9240, 9260, 9261]])","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"(Image: )","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Figure 2: Cellular 3-complexes: (a) cuboidal mesh, with  0-, 1-, 2-, and 3-cells numbered with different colors; (b) exploded simplicial mesh, with 6 tetrahedra (3-cells) per mesh cube.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Similarly, you can generate a multidimensional mesh of d-simplexes (d=123dots) with the simplexGrid function, having as single parameter the (cuboidal) shape of the mesh.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Let us generate d (increasing in dimension) simplicial complexes partitioning a single hypercube 01^d:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> Lar.simplexGrid([1]) # one segment in [0,1] \r\n# output\r\n([0.0 1.0], Array{Int64,1}[[1, 2]])\r\n\r\njulia> Lar.simplexGrid([1,1]) # two triangles in [0,1]^2 \r\n# output\r\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\r\n\r\njulia> Lar.simplexGrid([1,1,1])  # six tetrahedra in [0,1]^3 \r\n# output\r\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Array{Int64,1}[[1, 2, 3, 5],\r\n[2, 3, 5, 6], [3, 5, 6, 7], [2, 3, 4, 6], [3, 4, 6, 7], [4, 6, 7, 8]])\r\n\r\njulia> Lar.simplexGrid([1,1,1,1])  # 24 pentatopes in [0,1]^4 \r\n# output\r\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0],\r\nArray{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13],\r\n[2, 3, 5, 6, 10]  …  [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7,\r\n8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]]) ","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Then look at the simplicial partition (3D triangulation) of the domain 020times020times020 subset mathbfR^3 shown in Figure 1b, and generated by the Julia expression below:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"julia> Lar.simplexGrid([20,20,20]) \r\n# output\r\n([0.0 1.0 … 19.0 20.0; 0.0 0.0 … 20.0 20.0], Array{Int64,1}[[1, 2, 22], [2, 22, 23], [2,\r\n3, 23], [3, 23, 24], [3, 4, 24], [4, 24, 25], [4, 5, 25], [5, 25, 26], [5, 6, 26], [6, 26,\r\n27]  …  [415, 416, 436], [416, 436, 437], [416, 417, 437], [417, 437, 438], [417, 418,\r\n438], [418, 438, 439], [418, 419, 439], [419, 439, 440], [419, 420, 440], [420, 440,\r\n441]]) ","category":"page"},{"location":"mapper/#List-of-currently-available-primitives","page":"General Informations","title":"List of currently available primitives","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"The mapper module aims to provide the tools needed to apply both dimension-independent affine transformations and general simplicial maps to geometric objects and assemblies developed within the LAR scheme. A large number of surfaces and primitives solids are definable using the map function and the local parametrization.","category":"page"},{"location":"mapper/#Curves","page":"General Informations","title":"Curves","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Primitive one-dimensional objects:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"circle - Circle centered in the origin\nhelix - Helix curve about the z axis ","category":"page"},{"location":"mapper/#Surfaces","page":"General Informations","title":"Surfaces","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"(Image: )","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Figure 3: Cellular 1- and 2-complexes: (a) 2D unit circle; (b) spiral curve embedded in 3D; (c) 2D unit disk; (3) spiraloid surface in 3D.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Primitive two-dimensional objects:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"disk - Disk centered in the origin\nhelicoid - Helicoid about the z axis\nring - Ring centered in the origin\ncylinder - Cylinder surface with z axis\nsphere - Spherical surface of given radius\ntoroidal - Toroidal surface of given radiuses\ncrown - Half-toroidal surface of given radiuses","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"(Image: )","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Figure 4: Cellular 2- and 3-complexes: (a) 2D disk; (b) cylinder surface in 3D; (c) 2-sphere surface in 3D; (3) toroidal surface in 3D.","category":"page"},{"location":"mapper/#Solids","page":"General Informations","title":"Solids","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Primitive three-dimensional objects:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"cuboid - Solid cuboid of given extreme vectors\nball - Solid Sphere of given radius\nrod - Solid cylinder of given radius and height\nhollowCyl - Hollow cylinder of given radiuses and height \nhollowBall - Hollow sphere of given radiuses\ntorus - Solid torus of given radiuses\npizza - Solid pizza of given radiuses","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"(Image: )","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Figure 5: Cellular complexes: (a) 1-skeleton of 3D cube; (b) assembly of cell complexes of mixed dimensions; (c) 3-mesh of portion of hollow solid cylinder; (d) 3-mesh of a portion of hollow solid torus.","category":"page"},{"location":"mapper/#Implementation","page":"General Informations","title":"Implementation","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"The coding of the generating functions for the various geometric primitives follows the below guidelines:","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"*\t Higher level function interface. Every generating function is of type fun parms_1 to (parms_2 to results) with parms_1=p_1times p_2times cdots times p_m and parms_2=q_1times q_2times cdots times q_n. The p_i parameters concern the specification of the coordinate functions of the mapping. The q_j parameters (1leq jleq nin123)  affect the discretization of mapping domain.","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"*\t Simplicial or cuboidal decomposition.  Discretization primitives simplexGrid() or cuboidGrid() are used for the two cases. Both primitives are dimension-independent, i.e. may decompose 1D, 2D, 3D,..., nD domains, depending only on the array shape of the generated cellular complex. The complex is generated in LAR format (vertices,cells), where vertices have integer coordinates. ","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"*\t Coordinate functions. Are applied to the integer vertices, so producing their mapped instances and store them in a Array{Array{Int64,1},1}","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"*\tComplex simplification. Finally, the geometrically coincident vertices are identified, the generated cells are translated to the new vertex indices, and cells are simplified from multiple identical indices. This may induce the sewing of domain boundaries according to expected topology of the curved manifold and/or the reduction of independent vertices in cells of the complex.","category":"page"},{"location":"mapper/#Main-Interface","page":"General Informations","title":"Main Interface","text":"","category":"section"},{"location":"mapper/#Curve-primitives","page":"General Informations","title":"Curve primitives","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.circle","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.helix","category":"page"},{"location":"mapper/#Surface-primitives","page":"General Informations","title":"Surface primitives","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.disk","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.helicoid","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.ring","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.cylinder","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.sphere","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.toroidal","category":"page"},{"location":"mapper/#Solid-primitives","page":"General Informations","title":"Solid primitives","text":"","category":"section"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.cuboid","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.ball","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.hollowCyl","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.hollowBall","category":"page"},{"location":"mapper/","page":"General Informations","title":"General Informations","text":"Lar.torus","category":"page"}]
}
