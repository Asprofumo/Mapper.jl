<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Mapper.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Mapper.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Mapper.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduzione</a></li><li><a class="tocitem" href="../stateart/">Stato dell&#39;arte</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Funzioni"><span>Funzioni</span></a></li></ul></li><li><a class="tocitem" href="../grafodipendenze/">Grafo delle Dipendenze</a></li><li><a class="tocitem" href="../background/">BackGround Tecnologico</a></li><li><a class="tocitem" href="../applicazione/">Applicazione Pratica</a></li><li><a class="tocitem" href="../conclusioni/">Conclusione</a></li><li><a class="tocitem" href="../lar/">Lar Introduction</a></li><li><a class="tocitem" href="../mapper/">General Informations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Asprofumo/mapper.jl/blob/master/docs/src/indice.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Riferimenti"><a class="docs-heading-anchor" href="#Riferimenti">Riferimenti</a><a id="Riferimenti-1"></a><a class="docs-heading-anchor-permalink" href="#Riferimenti" title="Permalink"></a></h1><p>Questa pagina contiene riferimenti a tutti i tipi e funzioni esportati.</p><h2 id="Funzioni"><a class="docs-heading-anchor" href="#Funzioni">Funzioni</a><a id="Funzioni-1"></a><a class="docs-heading-anchor-permalink" href="#Funzioni" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Mapper.surface" href="#Mapper.surface"><code>Mapper.surface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">sphere(radius=1., angle1=pi, angle2=2*pi)(shape=[18, 36])</code></pre><p>Compute a cellular 2-complex, approximation of the two-dimensional closed surface, embedded in a three-dimensional Euclidean space. Geographical coordinates are user to compute the 0-cells of the complex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.sphere()()..., GL.COLORS[1],0.75 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.approxVal-Tuple{Any}" href="#Mapper.approxVal-Tuple{Any}"><code>Mapper.approxVal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approxVal(PRECISION)(value)</code></pre><p>Transform the float <code>value</code> to get a <code>PRECISION</code> number of significant digits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.ball" href="#Mapper.ball"><code>Mapper.ball</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ball(radius=1, angle1=pi, angle2=2*pi)(shape=[18, 36,4])</code></pre><p>Generate a cell decomposition of a <em>solid 3-sphere</em> in <span>$R^3$</span>. The variable <code>shape</code> provides the domain decomposition. Empty cells are removed after the <em>Cartesian -&gt; Polar</em> coordinate mapping.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLPol( Lar.ball()()..., GL.COLORS[1],0.5 ),
	GL.GLFrame ]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.circle" href="#Mapper.circle"><code>Mapper.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circle(radius=1.; angle=2*pi)(shape=36)</code></pre><p>Compute an approximation of the circunference curve in 2D, centered on the origin.</p><p>With default values, i.e. <code>circle()()</code>, return the whole circonference of unit radius, approximated with a <code>shape=36</code> number of 1-cells.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; W,CW = Lar.circle()();

julia&gt; GL.VIEW([
	GL.GLLines(W, CW, GL.COLORS[12]),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.crown" href="#Mapper.crown"><code>Mapper.crown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crown(r=1., R=2., angle=2*pi)(shape=[24, 36])</code></pre><p>Compute a cellular 2-complex, approximation of a two-dimensional open surface, embedded in a three-dimensional Euclidean space. This open surface is generated as an &quot;half-torus&quot;, providing only the external shell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.crown()()..., GL.COLORS[1],0.75 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.cuboid" href="#Mapper.cuboid"><code>Mapper.cuboid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cuboid(maxpoint::Array, full=false, minpoint::Array=zeros(length(maxpoint)))</code></pre><p>Return a <span>$d$</span>-dimensional cube, where <span>$d$</span> is the common length of arrays <code>minpoint</code> and <code>maxpoint</code>. If <code>flag=true</code> the cells of all dimensions (between 1 and <span>$d$</span>) are generated.</p><pre><code class="language-julia hljs">julia&gt; cuboid([-0.5, -0.5])
([0.0 0.0 -0.5 -0.5; 0.0 -0.5 0.0 -0.5], Array{Int64,1}[[1, 2, 3, 4]])

julia&gt; cuboid([-0.5, -0.5, 0], true)
([0.0 0.0 … -0.5 -0.5; 0.0 0.0 … -0.5 -0.5; 0.0 0.0 … 0.0 0.0],
Array{Array{Int64,1},1}[Array{Int64,1}[[1], [2], [3], [4], [5], [6], [7], [8]],
Array{Int64,1}[[1, 2], [3, 4], [5, 6], [7, 8], [1, 3], [2, 4], [5, 7], [6, 8], [1, 5], [2,
6], [3, 7], [4, 8]], Array{Int64,1}[[1, 2, 3, 4], [5, 6, 7, 8], [1, 2, 5, 6], [3, 4, 7,
8], [1, 3, 5, 7], [2, 4, 6, 8]], Array{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]]])

julia&gt; V, (VV, EV, FV, CV) = Lar.cuboid([1,1,1], true);

julia&gt; assembly = Lar.Struct([ (V, CV), Lar.t(1.5,0,0), (V, CV) ])

julia&gt; GL.VIEW([
	GL.GLPol( Lar.struct2lar(assembly)..., GL.COLORS[1],0.75 ),
	GL.GLFrame ]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.cylinder" href="#Mapper.cylinder"><code>Mapper.cylinder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cylinder(radius=.5, height=2., angle=2*pi)(shape=[36, 1])</code></pre><p>Compute a cellular 2-complex, approximation of a right circular cylindrical surface in 3D. The open surface has basis on <span>$z=0$</span> plane and is centered around the <span>$z$</span> axis.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.cylinder()()..., GL.COLORS[1],1 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.disk" href="#Mapper.disk"><code>Mapper.disk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disk(radius=1., angle=2*pi)(shape=[36, 1])</code></pre><p>Compute the cellular complex approximating a circular sector of 2D disk centered on the origin. In geometry, a disk is the region in a plane bounded by a circle. The <code>shape</code> array provides the number of approximating 2-cells.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.disk()()..., GL.COLORS[1],1 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.helicoid" href="#Mapper.helicoid"><code>Mapper.helicoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">helicoid(R=1., r=0.5, pitch=1., nturns=2)(shape=[36*nturns, 2])</code></pre><p>Compute an approximation of the helicoid surface in 3D, with basis on <span>$z=0$</span> plane and centered around the <span>$z$</span> axis.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.helicoid()()..., GL.COLORS[1],1 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.helix" href="#Mapper.helix"><code>Mapper.helix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">helix(radius=1., pitch=1., nturns=2)(shape=36*nturns)</code></pre><p>Compute the approximate elix curve in three-dimensional space, with basis on <span>$z=0$</span> plane and centered around the <span>$z$</span> axis. The <code>pitch</code> of a helix is the height of one complete helix <code>turn</code>, measured parallel to the axis of the helix.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; V, CV = Lar.helix(.1, .1, 10)()
([0.1 0.0984808 … 0.0984808 0.1; 0.0 0.0173648 … -0.0173648 0.0; 0.0 0.0027778 … 0.997222 1.0], Array{Int64,1}[[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]  …  [351, 352], [352, 353], [353, 354], [354, 355], [355, 356], [356, 357], [357, 358], [358, 359], [359, 360], [360, 361]])

julia&gt; GL.VIEW([
	GL.GLLines(V, CV, GL.COLORS[12]),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.hollowBall" href="#Mapper.hollowBall"><code>Mapper.hollowBall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hollowBall(r=1., R=2., angle1=pi, angle2=2*pi)(shape=[36, 1, 1])</code></pre><p>Compute the cellular 3-complex approximating a 3-sphere. The model is meshed with cubical 3-cells, where the mesh has default decomposition size <code>[24, 36, 8]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; V, CV = Lar.hollowBall(1, 2, pi/2, pi/2)([6, 12, 4]);

julia&gt; GL.VIEW([
 	GL.GLPol( V, CV, GL.COLORS[1],0.5 ),
 	GL.GLFrame ]);
...</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.hollowCyl" href="#Mapper.hollowCyl"><code>Mapper.hollowCyl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hollowCyl(r=1., R=2., height=6., angle=2*pi)(shape=[36, 1, 1])</code></pre><p>Compute the cellular 3-complex approximating a solid cylinder with a internal axial hole. The model is meshed with cubical 3-cells.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
 	GL.GLPol( Lar.hollowCyl()()..., GL.COLORS[1],0.5 ),
 	GL.GLFrame ]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.pizza" href="#Mapper.pizza"><code>Mapper.pizza</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pizza(r=.1, R=1., angle=pi)(shape=[24, 36])</code></pre><p>Compute a cellular 3-complex with a single convex 3-cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = pizza(r=.1, R=1., angle=pi)([12,18])

julia&gt; model[1]
3×249 Array{Float64,2}:
0.799215  0.997552   0.871665   0.573303  …   0.8463      0.964127  0.985637    0.0   0.0
0.670621  0.175895   0.573303   0.871665      0.55662     0.415884  0.2336      0.0   0.0
0.025     0.0482963  0.025     -0.025        -0.0482963  -0.0       0.0482963  -0.05  0.05

julia&gt; model[2]
1-element Array{Array{Int64,1},1}:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  240, 241, 242, 243, 244, 245, 246, 247, 248, 249]

julia&gt; GL.VIEW([
    GL.GLPol( pizza()()..., GL.COLORS[1],0.5 ),
    GL.GLFrame ]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.ring" href="#Mapper.ring"><code>Mapper.ring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ring(r=1., R=2., angle=2*pi)(shape=[36, 1])</code></pre><p>Compute the cellular 2-complex approximating a (possibly full) sector of a non-contractible disk. <code>R</code> and <code>r</code> are the external and the internal radiuses, respectively.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.ring()()..., GL.COLORS[1],1 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.rod" href="#Mapper.rod"><code>Mapper.rod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rod(radius=1, height=3, angle=2*pi)(shape=[36, 1])</code></pre><p>Compute a cellular 3-complex with a <em>single</em> 3-cell starting from a cyclindrical surface generated with the same parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; rod()()[1]
# output
3×74 Array{Float64, 2}:
 -0.34202   0.984808   1.0          1.0  …   0.984808  -0.866025  -1.0           0.766044
  0.939693  0.173648  -2.44929e-16  0.0     -0.173648  -0.5        1.22465e-16  -0.642788
  3.0       3.0        0.0          0.0      0.0        3.0        3.0           0.0

julia&gt; rod()()[2]
# output
1-element Array{Array{Int64, 1}, 1}:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9  …  64, 65, 66, 67, 68, 69, 70, 71, 72, 73]

julia&gt; GL.VIEW([
 	GL.GLPol( Lar.rod()()..., GL.COLORS[1],0.5 ),
 	GL.GLFrame ]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.simplifyCells-Tuple{Any, Any}" href="#Mapper.simplifyCells-Tuple{Any, Any}"><code>Mapper.simplifyCells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">W,CW = simplifyCells(V,CV)</code></pre><p>Find and remove the duplicated vertices and the incorrect cells. Some vertices may appear two or more times, due to numerical errors on mapped coordinates. Close vertices are identified, according to the PRECISION number of significant digits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.toroidal" href="#Mapper.toroidal"><code>Mapper.toroidal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toroidal(r=1., R=2., angle1=2*pi, angle2=2*pi)(shape=[24, 36])</code></pre><p>Compute a cellular 2-complex, approximation of the two-dimensional surface, embedded in a three-dimensional Euclidean space. Toroidal is a closed surface having genus one, and therefore possessing a single &quot;hole&quot;. It can be constructed from a rectangle by gluing both pairs of opposite edges together with no twists.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
	GL.GLGrid( Lar.toroidal()()..., GL.COLORS[1],0.75 ),
	GL.GLFrame
]);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mapper.torus" href="#Mapper.torus"><code>Mapper.torus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">torus(r=1., R=2., h=.5, angle1=2*pi, angle2=2*pi)(shape=[24, 36, 4])</code></pre><p>Compute the cellular 3-complex approximating the solid torus in 3D. The model is meshed with cubical 3-cells, where the mesh has default decomposition size <code>[24, 36, 4]</code>. See also: <a href="@toroidal"><code>toroidal</code></a>. <code>h</code> is radius of the circular hole inside the solid.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; GL.VIEW([
 	GL.GLPol( Lar.torus(1., 2., .5, pi, pi)()..., GL.COLORS[1],0.5 ),
 	GL.GLFrame ]);</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stateart/">« Stato dell&#39;arte</a><a class="docs-footer-nextpage" href="../grafodipendenze/">Grafo delle Dipendenze »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Wednesday 29 June 2022 16:12">Wednesday 29 June 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
